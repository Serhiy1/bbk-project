= BBK-project

:toc:

== 1. abstract

- Designing a platform for sharing information between multiple parties in a manner that is secure and provides provenance and reliability
// Change line, copied and pasted
- The report will describe the development process of this project, its design, technical decisions, and architecture.  


== 2. Introduction

[discrete]
=== Problem statement
* Mention how the world is changing, with companies introducing more automation
* This automation requires the quick transfer of information between parties
* A problem arises when the data cannot be trusted and needs to be verified
** Note: Add all the issues with untrusted data here. 
** Note: Data can come in all shapes and forms but must be trusted. A manufacturing corp could need to trust an invoice document while a newspaper   needs to trust a photo is not AI-generated  
** Fake: Fake invoices, faked images
** He said / she said fights

* This is currently rectified with manual process checks, and a "shadow IT." department emerges
* This problem undoes all the benefits of automation 

High-level description of my solution: 
* Create an API-first SASS service for sharing data 
* Data Needs to be shared securely and in a structured manner
* Note the need for cryptographic assurance. Mention SCITT, Merkle trees, and smart contracts. 
** But this is beyond the scope of the uni project

[discrete]
=== Industry Links 
* https://datatracker.ietf.org/group/scitt/about/
* https://www.digitaltwinconsortium.org/working-groups/manufacturing/
* https://c2pa.org/specifications/specifications/1.3/explainer/Explainer.html

[discrete]
=== Links to posts from people who are making similar products   
* https://www.datatrails.ai/solutions
* https://medium.com/@jmckenty/a-proposed-policy-framework-for-synthetic-media-532d2d4b7791
* https://medium.com/p/39ba0b26758a


== 3. Terminology 

* CI - Continuous integration.
* CD - Continuous Deployment.
* CLI - Command Line Interface
* GCP - Google cloud platform


== 4 Requirements

//  Copied and pasted need to update 
=== 4.1 Functional
Requirement 1: Users should be able to sign up.
Requirement 2: Users should be able to log events into the system.
Requirement 3: Users should be able to share logged events with users on the system.
//  This one is shit, make it better  
Requirement 4: Users should be able to create additional application users to make integration easier

// Additional ones that I may want to add
// 1. Attaching rich information to events 
// 2. Some kind of verification system with hashes? 


=== 4.2 Non Functional 

NFR1: High Availability.
1. System design should be fault-tolerant.
2. The system should appear as always available.

NFR2: Low latency.
1. Chat messages must be sent between participating peers in real-time.

NFR3: Maintainability
1. The system should be designed in a way that is easy to maintain.
2. The system should be designed to develop each component independently.

NFR4: Scalability
1. The system should be horizontally scalable on demand.

NFR5: Security.
1. Data transmitted over the Blitzshare network should be secure and protected.

=== 4.3 Use cases and designs

==== Authentication
1. Diagram for signing up 
// This will be first a password + email token exchange.  
// Follow up implementation with the UI will probably change this 
* User POSTS JSON to the SignUp endpoint with, email, username and password
** Email And username need to be unique, password complexity to be met
* If requirements are met, a new tenancy is created and a token for it is returned  

2. Diagram for logging in 
* User POSTS JSON with the email and password. 
* If a user record is found with the matching email and password a token is returned 

===== API Paths 
Sign in Paths
* POST ${host}/signup {"email" : str, "password" : str, "username"}
** No authentication needed
** Returns 200 {"token" : str, "tennant ID" : str}
** Returns 4xx if email is in use (don't know the correct status code)
** Returns 4xx if password complexity is not met (don't know the correct status code)

* POST ${host}/Login
** No authentication needed
** POST {"email" : "str", "password" : str}
** Returns 200 {"token" : str}
** Returns 4xx if email does not exist (don't know the correct status code)
** Returns 4xx if password does not match (don't know the correct status code)

* GET ${host}/whoami
** Jwt Header needed
** GET ${host}/whoami
** returns {"email" : str, "tenant ID" : str}

==== Applications
1. Making an application registration
* authenticated User GETS from the Registration endpoint 
* An App registration ID + secret is returned 

2. User authenticates an application registration
* User runs the login process with, but provides the application ID and Secret

3. User Rolls the secret for an application
* authenticated User GETS from the Registration endpoint with the application ID in the URI  

4. User Deletes A registration
* authenticated User DELETES from the Registration endpoint with the application ID in the URI  

===== API Paths 
All Paths require a Jwt Authentication, otherwise 403 is returned
* GET ${host}/App
** Returns 201 {"appID": str, "secret" : str}

* GET ${host}/App/${appID}/newSecret
** Returns 200 {"appID": str, "secret" : str}

* DELETE ${host}/App/${appID}
** Returns 200 (don't know the correct status code)

=== Projects
// Start first with document storage, talk about future improvement using time series storage
1. Creating a project 
* POST to the project endpoint with initial details in JSON format
* Project JSON along with an ID 
// TODO Select what is the required Data

2. Updating a project
* PATCH to the project ID with JSON, Key value pairs are overwritten
* Update is logged as an event with a Diff as the events content 
// version changes need to be logged

3. Viewing the A Project history 
* GET to a project ID
* Returns current project details + A list of Diffs from PATCH request and a list or events  

4. Viewing All projects
* GET on the project endpoint
* Returns a list of project ID with their details 

==== API Paths
All Paths require a Jwt Authentication, otherwise 403 is returned
Any Validation errors are 400 responses
* Creating a project 
** POST ${host}/Projects     {"project name" : str, "Custom Meta data" : {str : str}}
** Returns 201 {"project name": str, "Project ID" : uuid, "Started Date" : Date, "Custom Meta data" : {str : str}} (This is a project type)

* Updating a project
** PATCH ${host}/Projects/${projectID}     {"project name" : str, "Custom Meta data" : {str : str}}      (This is a diff type)
** return 200 (not sure) {"project name": str, "Project ID" : uuid, "Started Date" : Date, "Custom Meta data" : {str : str}} 

* Project Overview 
** GET ${host}/Projects/${projectID}
** Return 200 {"project name": str, "Project ID" : uuid, "Started Date" : Date, "Custom Meta data" : {str : str}, [Diffs], [Events]}

* View all projects
** GET ${host}/Projects
** Return 200 {[project]}

=== Events

1. Adding Events to a Project 
* POST JSON to the project id with event suffix
* Returns the JSON with the event ID

2. Viewing all Events on a project   
* POST JSON to the project id with event suffix
* Returns A list of all the events on the project
 
3. Attaching Rich Items to an event
// https://cloud.google.com/storage/?hl=en
* POST the data the rich evidence endpoint
// See if metadata can be added
* Returns an id for the evidence
* POST an event to a project with said ID  




=== Collaborators 
1. Linking to collaborators
* POST collaborator tenant ID to collaborators endpoint
// Add some user friendly data, as well as ways to update that data 
* PENDING status is returned
* collaborator POSTS your tenant ID back to the collaborators endpoint
* PENDING status is updated to ACTIVE 

2. Viewing all available collaborators       
* GET on the collaborators endpoint
* list is returned containing collaborator ID and their status
// list what projects they are on 
// user friendly info   

3. Adding collaborators to a project 
* POST to the project ID with collaborators suffix JSON containing the ID that you want to add 
* Returns 200 depending on collaborator is ACTIVE 

4. Removing collaborators from a project  
// Need to keep in mind the "once shared always shared principal"
* DELETE to the project ID with collaborators suffix JSON containing the ID that you want to add

5. Removing collaborators Completely  
// Need to keep in mind the "once shared always shared principal"
// Cannot be done until collaborator is removed from all projects 
* DELETE to collaborator tenant ID to collaborators endpoint
* collaborator ID is removed from list 
* Status on Collaborator side is set to PENDING 

