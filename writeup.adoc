= BBK-project

:toc:

== 1. abstract

- Designing a platform for sharing information between multiple parties in a manner that is secure and provides provenance and reliability
// Change line, copied and pasted
- The report will describe the development process of this project, its design, technical decisions, and architecture.  


== 2. Introduction

[discrete]
=== Problem statement
* Mention how the world is changing, with companies introducing more automation
* This automation requires the quick transfer of information between parties
* A problem arises when the data cannot be trusted and needs to be verified
** Note: Add all the issues with untrusted data here. 
** Note: Data can come in all shapes and forms but must be trusted. A manufacturing corp could need to trust an invoice document while a newspaper   needs to trust a photo is not AI-generated  
** Fake: Fake invoices, faked images
** He said / she said fights

* This is currently rectified with manual process checks, and a "shadow IT." department emerges
* This problem undoes all the benefits of automation 

High-level description of my solution: 
* Create an API-first SASS service for sharing data 
* Data Needs to be shared securely and in a structured manner
* Note the need for cryptographic assurance. Mention SCITT, Merkle trees, and smart contracts. 
** But this is beyond the scope of the uni project

[discrete]
=== Industry Links 
* https://datatracker.ietf.org/group/scitt/about/
* https://www.digitaltwinconsortium.org/working-groups/manufacturing/
* https://c2pa.org/specifications/specifications/1.3/explainer/Explainer.html

[discrete]
=== Links to posts from people who are making similar products   
* https://www.datatrails.ai/solutions
* https://medium.com/@jmckenty/a-proposed-policy-framework-for-synthetic-media-532d2d4b7791
* https://medium.com/p/39ba0b26758a


== 3. Terminology 

* CI - Continuous integration.
* CD - Continuous Deployment.
* CLI - Command Line Interface
* GCP - Google cloud platform


== 4 Requirements

//  Copied and pasted need to update 
=== 4.1 Functional
Requirement 1: Users should be able to sign up.
Requirement 2: Users should be able to log events into the system.
Requirement 3: Users should be able to share logged events with users on the system.
//  This one is shit, make it better  
Requirement 4: Users should be able to create additional application users to make integration easier

// Additional ones that I may want to add
// 1. Attaching rich information to events 
// 2. Some kind of verification system with hashes? 


=== 4.2 Non Functional 

NFR1: High Availability.
1. System design should be fault-tolerant.
2. The system should appear as always available.

NFR2: Low latency.
1. Chat messages must be sent between participating peers in real-time.

NFR3: Maintainability
1. The system should be designed in a way that is easy to maintain.
2. The system should be designed to develop each component independently.

NFR4: Scalability
1. The system should be horizontally scalable on demand.

NFR5: Security.
1. Data transmitted over the Blitzshare network should be secure and protected.

=== 4.3 Use cases and designs

==== Authentication
1. Diagram for signing up 
// This will be first a password + email token exchange.  
// Follow up implementation with the UI will probably change this 
* User POSTS JSON to the SignUp endpoint with, email, username and password
** Email And username need to be unique, password complexity to be met
* If requirements are met, a new tenancy is created and a token for it is returned  

2. Diagram for logging in 
* User POSTS JSON with the email and password. 
* If a user record is found with the matching email and password a token is returned 

===== API Paths 
Sign in Paths
* POST ${host}/signup {"email" : str, "password" : str, "username"}
** No authentication needed
** Returns 200 {"token" : str, "tennant ID" : str}
** Returns 4xx if email is in use (don't know the correct status code)
** Returns 4xx if password complexity is not met (don't know the correct status code)

* POST ${host}/Login
** No authentication needed
** POST {"email" : "str", "password" : str}
** Returns 200 {"token" : str}
** Returns 4xx if email does not exist (don't know the correct status code)
** Returns 4xx if password does not match (don't know the correct status code)

* GET ${host}/whoami
** Jwt Header needed
** GET ${host}/whoami
** returns {"email" : str, "tenant ID" : str}

==== Applications
1. Making an application registration
* authenticated User GETS from the Registration endpoint 
* An App registration ID + secret is returned 

2. User authenticates an application registration
* User runs the login process with, but provides the application ID and Secret

3. User Rolls the secret for an application
* authenticated User GETS from the Registration endpoint with the application ID in the URI  

4. User Deletes A registration
* authenticated User DELETES from the Registration endpoint with the application ID in the URI  

===== API Paths 
All Paths require a Jwt Authentication, otherwise 403 is returned
* GET ${host}/App
** Returns 201 {"appID": str, "secret" : str}

* GET ${host}/App/${appID}/newSecret
** Returns 200 {"appID": str, "secret" : str}

* DELETE ${host}/App/${appID}
** Returns 200 (don't know the correct status code)

=== Projects
// Start first with document storage, talk about future improvement using time series storage
1. Creating a project 
* POST to the project endpoint with initial details in JSON format
* Project JSON along with an ID 
// TODO Select what is the required Data

2. Updating a project
* PATCH to the project ID with JSON, Key value pairs are overwritten
* Update is logged as an event with a Diff as the events content 
// version changes need to be logged

3. Viewing the A Project history 
* GET to a project ID
* Returns current project details + A list of Diffs from PATCH request and a list or events  

4. Viewing All projects
* GET on the project endpoint
* Returns a list of project ID with their details 

==== API Paths
* All Paths require a Jwt Authentication, otherwise 403 is returned
* Any Validation errors are 400 responses + violation explanation 
* Any project IDs or Event ID's that are not found return 404 responses

===== Types
* "project submission type" : {{"project name (Required)" : str, "Custom Meta data (optional)" : {str : str}} } 
* "project return type" : {"project name": str, "Project ID" : uuid, "Started Date" : Date, "Custom Meta data (if present)" : {str : str}}

* "project diff submission type": {{"project name (optional)" : str, "Custom Meta data (optional)" : {str : str}} } 
* "Return diff type": {"project name" : {"old" : str, "new" : str}, "custom meta data" : {str: {"old" : str, "new" : str}}}

// Event references
* Attachment type {"attachment name (Required)" : "blob uuid (Required)" : uuid}
* Event Submission Type {"Event Name (Required)" : str, "Event type (Required)" : str, "Custom Meta Data (optional)" : {str : str} : "attachments (optional)": {"attachment type"} }
* Event return type {"Event ID" : uuid, "Event Date" : Date, (unpack event submission type)}

===== Input validators
Project name : (1-64 chars (control chars disallowed) )
Custom meta Data: (optional)(key: 1-64 chars, value: 1024 chars (control chars disallowed))
attachment name : (1-64 chars (control chars disallowed) )
event name : (1-64 chars (control chars disallowed))
event type : (1-64 chars (control chars disallowed))

* Creating a project 
** POST ${host}/Projects  "project submission type"   
** Returns 201  "Project Return type" 

* Updating a project
** PATCH ${host}/Projects/${projectID}     "project diff submission type"
** return 200 (not sure)    "Return diff type" 

* Project Overview 
** GET ${host}/Projects/${projectID}
** Return 200 {"project return type", ["Return diff type"], ["Event return type"]}
** return 404 if project is not found

* View all projects
** GET ${host}/Projects
** Return 200 {["project return type"]}

=== Events

1. Adding Events to a Project 
* POST JSON to the project id with event suffix
* Returns the JSON with the event ID

2. Viewing all Events on a project   
* POST JSON to the project id with event suffix
* Returns A list of all the events on the project
 
==== API paths
* All Paths require a Jwt Authentication, otherwise 403 is returned  
* Any Validation errors are 400 responses  
* Any project IDs or Event ID's that are not found return 404 responses

* Create an event on a project
** POST ${host}/Projects/${project ID}/events      userSubmit/EventType
** Returns 201  AppReturn/EventType

* View Single Event
** GET ${host}/Projects/${project ID}/events/${event ID}
** Returns 200 AppReturn/EventType

* View all Events on a project 
** GET ${host}/Projects/${project ID}/events
** Returns 200 [AppReturn/EventType]


=== Upload Attachments API Paths
* All Paths require a Jwt Authentication, otherwise 403 is returned  
* Any blobID's that are not found return 404 responses

* Creating a attachment so it can be referenced in a event 
** POST ${host}/attachments    {"filename" : str, "extension" : str, binary data}
** Returns 201 {"blob uuid" : uuid, "upload date": Date }


* Creating a attachment so it can be referenced in a event 
** GET ${host}/attachments/${blob uuid}
** Returns 200 blob data


=== Collaborators 
1. Linking to collaborators
* POST collaborator tenant ID to collaborators endpoint
// Add some user friendly data, as well as ways to update that data 
* PENDING status is returned
* collaborator POSTS your tenant ID back to the collaborators endpoint
* PENDING status is updated to ACTIVE 

2. Viewing all available collaborators       
* GET on the collaborators endpoint
* list is returned containing collaborator ID and their status
// list what projects they are on 
// user friendly info   

3. Adding collaborators to a project 
* POST to the project ID with collaborators suffix JSON containing the ID that you want to add 
* Returns 200 if collaborator is ACTIVE 
* Returns 400 if collaborator is PENDING
* returns 404 if collaborator uuid is not found

4. Removing collaborators from a project  
// Need to keep in mind the "once shared always shared principal"
* DELETE to the project ID with collaborators suffix JSON containing the ID that you want to add

5. Removing collaborators Completely  
// Need to keep in mind the "once shared always shared principal"
// Cannot be done until collaborator is removed from all projects 
* DELETE to collaborator tenant ID to collaborators endpoint
* collaborator ID is removed from list 
* Status on Collaborator side is set to PENDING 

==== collaborators API

* All Paths require a Jwt Authentication, otherwise 403 is returned  
* Any collaborators ID's that are not found return 404 responses

schemas/userSubmit/collaborators.yaml = {"friendly name": str (1-64 chars (control chars disallowed)), tenantID: uuid}
schemas/AppReturn/collaborators.yaml = {"friendly name": str , tenantID: uuid, status: "PENDING|ACTIVE"}

* Adding collaborator
** POST ${host}/collaborators   userSubmit/collaborators.yaml
** returns 201 AppReturn/collaborators.yaml

* Viewing a single collaborator 
** GET ${host}/collaborators/${collaborator tenant id}   
** returns 200 AppReturn/collaborators.yaml

* Viewing all collaborators 
** GET ${host}/collaborators   
** returns 200 [AppReturn/collaborators.yaml]

* Removing a collaborator 
** DELETE ${host}/collaborators/${collaborator tenant id}
** returns 200 
** returns 400 if collaborator is still present on any projects 

==== Project Collaborators API 
* All Paths require a Jwt Authentication, otherwise 403 is returned  
* Any collaborators ID's or Project ID's that are not found return 404 responses

* Adding a Collaborator to a project
* POST ${host}/projects/${projectID}/Collaborators  {"collaborator" : "collaborator Tenant ID"}

* Viewing Current collaborators on a project
** GET ${host}/projects/${projectID}/Collaborators
** returns [schemas/AppReturn/collaborators.yaml] 

* Removing a collaborator from a project
** DELETE ${host}/projects/${projectID}/Collaborators/${collaborator tenant id}   